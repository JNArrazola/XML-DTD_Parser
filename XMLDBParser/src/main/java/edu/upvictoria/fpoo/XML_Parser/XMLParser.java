package edu.upvictoria.fpoo.XML_Parser;

import java.util.ArrayList;
import java.util.Stack;

/**
 * Parser class
 * The Parser class is responsible for parsing the tokens generated by the Lexer
 * class and interpreting the XML file.
  */
public class XMLParser {
  private int actual = 0;
  private Stack<TagNode> stack;
  private ArrayList<Token> tokens;
  private TagNode root;

  /**
   * Parse the tokens and generate the tree structure
   * @param tokens the tokens to parse
   * @return TagNode, object that is positioned at the root of the tree
    */  
  public TagNode parse(ArrayList<Token> tokens){
    stack = new Stack<TagNode>();
    this.tokens = tokens;
    root = null;

    while (getActualToken() != TokenType.EOF) {
      switch (getActualToken()) {
        case OPEN_TAG:
          if(peek() == TokenType.QUESTION_MARK){
            handleTrash();
            break;
          } else if(peek() == TokenType.EXCLAMATION){
            // TODO: This method is supposed to read the DTD
            // handleDTDRelation(); 
            break;
          } else if(peek() == TokenType.SLASH){
            handleCloseTag();
          } else if (peek() == TokenType.TAG_CONTENT){
            handleOpenTag();
          } else 
            ErrorHandler.throwError("Invalid tag: expected name", tokens.get(actual).getLine());
          break;
        case TAG_VALUE:
          handleTagValue();
          break;
        default:
          break;
      }
      advance();
    }

    // printTree(root, 0);
    return root;
  }

  /* Auxiliar methods */

  /**
   * Check next token type respecting the actual token
   * @return TokenType
    */
  private TokenType peek() {
    return tokens.get(actual + 1).getType();
  }

  /**
   * get the actual token type
   * @return TokenType
    */
  private TokenType getActualToken(){
    return tokens.get(actual).getType();
  }

  /**
   * Advance to the next token
    */
  private void advance() {
    actual++;
  }

  /**
   * Print the tree structure
   * @param node the node to print
   * @param level the level of the node
    */
    public void printTree(TagNode node, int level){
    for(int i = 0; i < level; i++)
      System.out.print("  ");
    System.out.println(node.getName());
    
    if(node.getContent() != null){
      for(int i = 0; i < level; i++)
        System.out.print("  ");
      System.out.println("Content: " + node.getContent());
    }

    if(!node.getAttributes().isEmpty()){
      for(Attribute attribute : node.getAttributes()){
        for(int i = 0; i < level; i++)
          System.out.print("  ");
        System.out.println(attribute.getName() + " = " + attribute.getValue());
      }
    }
    for(TagNode child : node.getChildren())
      printTree(child, level + 1);
  }

  //? Handlers

  /**
   * Method for handling tags that i will not use
    */
  private void handleTrash(){
    while(getActualToken() != TokenType.CLOSE_TAG)
      advance();
  }

  private void handleOpenTag(){
    advance();
    
    TagNode node = new TagNode();
    Stack<Token> tagTokens = new Stack<Token>();

    while(getActualToken() != TokenType.CLOSE_TAG){
      switch (getActualToken()) {
        case TAG_CONTENT:

          // If there is an equal sign, the next token must be a string 
          // ej. tag="value"
          if(!tagTokens.isEmpty() && tagTokens.peek().getType() == TokenType.EQUAL)
            ErrorHandler.throwError("Invalid tag: expected attribute value", tokens.get(actual).getLine());

          // If the node name is null, the first token must be the name of the tag
          // ej. <tag>
          if(node.getName() == null)
            node.setName(tokens.get(actual).getLexeme());
          else 
            tagTokens.push(tokens.get(actual)); // If the node name is not null, the token is an attribute
          break;
        case EQUAL:
          if(tagTokens.isEmpty())
            ErrorHandler.throwError("Invalid tag: expected attribute name after " + tokens.get(actual).getLexeme(), tokens.get(actual).getLine());
          tagTokens.push(tokens.get(actual));
          break;
        case STRING:
          if(tagTokens.isEmpty())
            ErrorHandler.throwError("Invalid tag: expected attribute value after " + tokens.get(actual).getLexeme(), tokens.get(actual).getLine());
          else if(tagTokens.peek().getType() != TokenType.EQUAL)
            ErrorHandler.throwError("Invalid tag: expected equal sign before " + tokens.get(actual).getLexeme(), tokens.get(actual).getLine());

          tagTokens.pop();
          node.addAttribute(new Attribute(tagTokens.pop().getLexeme(), tokens.get(actual).getLexeme()));
          break;
        default:
          break;
      }
      advance();
    } 

    if(!tagTokens.isEmpty())
      ErrorHandler.throwError("Don't recognized attribute: " + tagTokens.peek().getLexeme(), tokens.get(actual).getLine());

    if(!stack.empty())
      stack.peek().addChild(node);

    if(root == null)
      root = node;
    
    stack.push(node);
  }

  /**
   * Method for handling close tags
    */
  public void handleCloseTag(){
    advance(); // This is <
    advance(); // This is /
    
    if(stack.empty())
      ErrorHandler.throwError("Invalid tag: expected open tag", tokens.get(actual).getLine());

    String name = tokens.get(actual).getLexeme();
    TagNode node = stack.pop();

    if(!node.getName().equals(name))
      ErrorHandler.throwError("Invalid tag: expected " + node.getName() + " but found " + name, tokens.get(actual).getLine());
  }

  public void handleTagValue(){
    String value = tokens.get(actual).getLexeme() + " ";
    
    while(peek() != TokenType.OPEN_TAG){
      advance();
      value += tokens.get(actual).getLexeme() + " ";
    }
    stack.peek().setContent(value.trim());
  }
}